# There's a wonderful wrapper for TSP called tspmeta, with some extra features
# We're just using TSP directly to better understand the mechanics behind its algorithms

library("sp")
library("ggplot2")
library("maps")
library("maptools")
library("TSP")


# COORDINATES 

# Let's use continental U.S. states and DC as our coordinates. We generated these ourselves
# as described in the main README

states <- read.csv("../geography/data/state_coordinates.csv",
  colClasses=c(rep("character", 3), rep("numeric", 3))
)

# we'll give each one an explicit index since this is how tours are expressed
states$index <- seq(1:NROW(states))
labels <- states$name

# We need the coordinates as a two-column matrix of lng and lat
coords <- as.matrix(data.frame(long=states$long, lat=states$lat))


# DISTANCES BETWEEN STATES

miles_per_kilometer = 100000 / 2.54 / 12 / 5280

# Compute distance matrix. More on this in distance_spotcheck.R
dists <- spDists(coords, longlat = TRUE) * miles_per_kilometer

# dists is a 49 x 49 matrix--one row and column for each place--so the diagonals are zero since
# they represent the distance from, say, AL to AL. Setting to infinity helps TSP ignore them
diag(dists) = Inf
if (any(dists == 0)) {
  warning("Zero entry detected in TSP dist matrix!")
}

#dists[dists > 500] <- Inf

# THE SALESMAN TRAVELS

# initialize the TSP object. The library also has classes for Euclidean and assymetic varieties
tsp <- TSP(dists, labels)

# TSP has a few methods for checking the specs, though we don't really need them
n_of_cities(tsp)
labels(tsp)

methods_to_try <- c(
  "nearest_insertion",
  "farthest_insertion",
  "cheapest_insertion",
  "arbitrary_insertion",
  "nn",
  "repetitive_nn",
  "two_opt"
)

## calculate a tour
tour <- solve_TSP(tsp, method = "repetitive_nn")

## use that tour to practice our mapping function

# plot tour
# h/t https://uchicagoconsulting.wordpress.com/2011/04/18/how-to-draw-good-looking-maps-in-r/
plot_tour <- function(tour_order, title) {
  # We need the coordinates for the centroids in a data frame. While we could easily convert
  # `coords`, let's just use the original file from which it was derived. This has the same order 
  # as coords, which by default is just the states sorted by FIPS value
  coordinates <- states

  # The result of `solve_TSP` is a list of integers listing the index of the locations in the 
  # order they are to be visited. Thus, if the solution starts in California, the first digit 
  # would be 4. That's why we added the "index" column early on. Armed with that, we can make
  # a list of the states that is reordered according to the tour generated by the TSP algorithm.
  
  tour_coordinates = coordinates[as.numeric(tour_order), ]

  # the `segmented` boolean is going to determine whether we draw one long path or 48 short ones
  
  # let's check out our first 10 stops
  # print(tour_coordinates$name[1:10])

  # and number the states in order of their place in the tour
  tour_coordinates$tour_order <- seq(1:NROW(tour_coordinates))

  # MAP
  # Start with state borders
  all_states <- map_data("state") # Thanks for including this, ggplot2
  p <- ggplot()
  if (!missing(title)) {
    p <- p + labs(title = title) + theme(plot.title=element_text(hjust=0.5))
  }
  p <- p + geom_polygon( data=all_states, aes(x=long, y=lat, group = group), colour="black", fill="white")
  
  # Plot the centroids. Order doesn't matter, so we can use tour_coordinates
  p <- p + geom_point( data=tour_coordinates, aes(x=long, y=lat), color="black", size=3)

  # Plot the path in one fell swoop. Let's color it according to its progress from start to end, red to green
  p <- p + geom_path(data = tour_coordinates, aes(x= long, y = lat, color=tour_order), size=2) +
    scale_colour_gradientn( colours = c( "darkblue", "purple", "red"),
                            breaks  = c( 0, NROW(tour_coordinates) / 2, NROW(tour_coordinates)),
                            limits  = c( 0, NROW(tour_coordinates)))
  p <- p + theme(legend.position="none")
    
  print(p)
}


plot_tour(tour, "Test route")

# looks great! Let's iterate through the types a few times

for (c in 1:4) {
  for (method in methods_to_try) {
    tour <- solve_TSP(tsp, method = method)
    plot_tour(tour, paste(method, "-", c))
    Sys.sleep(4)
  }
}